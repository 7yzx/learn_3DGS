
[【计算机视觉】Gaussian Splatting源码解读补充（二）\_colmap free gaussians splatting github-CSDN博客](https://blog.csdn.net/qaqwqaqwq/article/details/136886008)

[详解3D Gaussian Splatting CUDA Kernel：前向传播 | Yin的笔记本](https://yindaheng98.github.io/%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E9%AB%98%E6%96%AF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90.html#%E5%BC%80%E5%A4%B4)
**cuda 中 block = tile，thread = pixel**
cuda 程序会使用的程序
```python
PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
  m.def("rasterize_gaussians", &RasterizeGaussiansCUDA);
  m.def("rasterize_gaussians_backward", &RasterizeGaussiansBackwardCUDA);
  m.def("mark_visible", &markVisible);
  m.def("adamUpdate", &adamUpdate);
  m.def("fusedssim", &fusedssim);
  m.def("fusedssim_backward", &fusedssim_backward);

}
```

## 1 数据准备

```cpp
// rasterize_points.cu
  // 这里的resizeFunctional是一个闭包，输出一个调显存空间大小lambda表达式，给后面代码里面分配显存用：
std::function<char*(size_t N)> resizeFunctional(torch::Tensor& t) {
    auto lambda = [&t](size_t N) {
        t.resize_({(long long)N});
		return reinterpret_cast<char*>(t.contiguous().data_ptr());
    };
    return lambda;
}
std::function<char*(size_t)> geomFunc = resizeFunctional(geomBuffer);

std::function<char*(size_t)> binningFunc = resizeFunctional(binningBuffer);

std::function<char*(size_t)> imgFunc = resizeFunctional(imgBuffer);


// rasterize_points.cu
size_t chunk_size = required<GeometryState>(P); //计算所需的显存大小
char* chunkptr = geometryBuffer(chunk_size); //分配显存块，并返回首地址
GeometryState geomState = GeometryState::fromChunk(chunkptr, P);//将分配的显存块初始化为GeometryState
```


1. **调用方 (`rasterize_points.cu`)**:
    
    - 创建一个空的PyTorch GPU Tensor，例如 `torch::Tensor geomBuffer`。
    - 创建一个Lambda表达式，这个Lambda捕获了 `geomBuffer`。当Lambda被调用时，它会调用 `geomBuffer.resize_()` 来调整Tensor大小，然后返回其 `.data_ptr()`。
    - 将这个Lambda作为 `geometryBuffer` 参数传递给 `CudaRasterizer::Rasterizer::forward` 函数。
2. **被调用方 (rasterizer_impl.cu])**:
    
    - 在 `forward` 函数内部，它首先计算出几何状态所需的总字节数，例如 `size_t chunk_size = required<GeometryState>(P);`。
    - 然后它调用传入的函数：`char* chunkptr = geometryBuffer(chunk_size);`。
    - 此时，在 `rasterize_points.cu` 中创建的Lambda被执行，PyTorch Tensor被调整到 `chunk_size` 大小，其GPU指针被返回。
    - `chunkptr` 现在就指向了一块由PyTorch管理的、大小合适的GPU内存，光栅化器可以安全地使用它。

### 1.1 分配内存的方式
`required<GeometryState>(P)` 分配空间大小的原理非常巧妙，它本质上是一种**模拟分配**或**干运行（Dry Run**的技巧，用来计算多个数据结构打包在一起所需的总内存，同时确保每个结构都满足CUDA的内存对齐要求。

我们来一步步拆解这个过程：
**核心思想**

系统并不想真的去分配内存，它只想知道**“如果我要分配，总共需要多大空间？”**。它通过一个从 `nullptr` (地址0) 开始的指针，模拟内存分配过程，不断地将指针向前移动，最终指针的数值就等于所需的总大小。
#### 1.1.1 入口：`required<GeometryState>(P)` 函数

我们先看 `required` 函数本身：



```cpp
	template<typename T> 
	size_t required(size_t P)
	{
		char* size = nullptr;
		T::fromChunk(size, P);
		return ((size_t)size) + 128;
	}
```

- `char* size = nullptr;`: 创建一个 `char` 指针并将其初始化为 `nullptr`。在数值上，`nullptr` 就是0。这个 `size` 指针将扮演我们的“卷尺”或“位置标记器”。
- `T::fromChunk(size, P);`: 这是关键。它调用了模板参数 `T`（在这里是 `GeometryState`）的静态方法 `fromChunk`。**非常重要的一点是，`size` 是通过引用 (`char*&`) 传递的**，这意味着 `fromChunk` 函数内部对这个指针的任何修改都会直接反映到 `required` 函数中的 `size` 变量上。
- `return ((size_t)size) + 128;`: `fromChunk` 执行完毕后，`size` 指针的值已经不再是0，而是模拟分配后的总大小。这里将它的地址值强制转换为一个整数 `size_t`，并加上128字节的额外余量（padding），然后返回。

#### 1.1.2 模拟器：`GeometryState::fromChunk` 函数

现在我们看 `fromChunk` 的实现，它定义了内存的“布局蓝图”：

```cpp
CudaRasterizer::GeometryState CudaRasterizer::GeometryState::fromChunk(char*& chunk, size_t P)
{
	GeometryState geom;
	obtain(chunk, geom.depths, P, 128);
	obtain(chunk, geom.clamped, P * 3, 128);
	obtain(chunk, geom.internal_radii, P, 128);
	obtain(chunk, geom.means2D, P, 128);
	obtain(chunk, geom.cov3D, P * 6, 128);
	obtain(chunk, geom.conic_opacity, P, 128);
	obtain(chunk, geom.rgb, P * 3, 128);
	obtain(chunk, geom.tiles_touched, P, 128);
	cub::DeviceScan::InclusiveSum(nullptr, geom.scan_size, geom.tiles_touched, geom.tiles_touched, P);
	obtain(chunk, geom.scanning_space, geom.scan_size, 128);
	obtain(chunk, geom.point_offsets, P, 128);
	return geom;
}

CudaRasterizer::ImageState CudaRasterizer::ImageState::fromChunk(char*& chunk, size_t N)
{
	ImageState img;
	obtain(chunk, img.accum_alpha, N, 128);
	obtain(chunk, img.n_contrib, N, 128);
	obtain(chunk, img.ranges, N, 128);
	return img;
}

CudaRasterizer::BinningState CudaRasterizer::BinningState::fromChunk(char*& chunk, size_t P)
{
	BinningState binning;
	obtain(chunk, binning.point_list, P, 128);
	obtain(chunk, binning.point_list_unsorted, P, 128);
	obtain(chunk, binning.point_list_keys, P, 128);
	obtain(chunk, binning.point_list_keys_unsorted, P, 128);
	cub::DeviceRadixSort::SortPairs(
		nullptr, binning.sorting_size,
		binning.point_list_keys_unsorted, binning.point_list_keys,
		binning.point_list_unsorted, binning.point_list, P);
	obtain(chunk, binning.list_sorting_space, binning.sorting_size, 128);
	return binning;
}
```

这个函数接收 `chunk` 指针（也就是 `required` 函数里的 `size` 指针，初始值为0）。然后它按顺序为 `GeometryState` 的每一个成员（`depths`, `clamped` 等）调用 `obtain` 函数。

---

#### 1.1.3 执行者：`obtain` 函数

`obtain` 函数是真正执行“测量”和“移动指针”操作的地方：

```cpp
template <typename T>
static void obtain(char*& chunk, T*& ptr, std::size_t count, std::size_t alignment)
{
	std::size_t offset = (reinterpret_cast<std::uintptr_t>(chunk) + alignment - 1) & ~(alignment - 1);
	ptr = reinterpret_cast<T*>(offset);
	chunk = reinterpret_cast<char*>(ptr + count);
}
```


让我们跟踪第一次调用 `obtain(chunk, geom.depths, P, 128)` 时发生了什么，此时 `chunk` 的值是0：

1. **计算对齐后的地址 (`offset`)**:
    - `reinterpret_cast<std::uintptr_t>(chunk)`: 将 `chunk` 指针 (0) 转为整数。
    - `(0 + 128 - 1) & ~(128 - 1)`: 这是一个标准的**内存对齐**算法。它计算出大于等于当前地址(0)的、最小的能被 `alignment`(128) 整除的地址。结果还是0。所以 `offset` 是0。
    - **为什么需要对齐？** CUDA核函数访问全局内存时，如果地址是对齐的（通常是32, 64或128字节的倍数），访问效率会高得多。这个操作确保了每个数组成员的起始地址都是对齐的。
2. **设置成员指针 (`ptr`)**:
    - `ptr = reinterpret_cast<T*>(offset);`: `geom.depths` 指针被设置为地址0。在这次“干运行”中，这个指针本身没有意义，我们不关心它的值。
3. **移动“卷尺” (`chunk`)**:
    - `chunk = reinterpret_cast<char*>(ptr + count);`: 这是最关键的一步。它将 `chunk` 指针向前移动。
    - `ptr + count` 是指针运算，它计算的地址是 `ptr` 的地址加上 `count * sizeof(T)` 个字节。在这里 `T` 是 `float`，`count` 是 `P`。
    - 所以 `chunk` 的新值变成了 `0 + P * sizeof(float)`。我们的“卷尺”现在指向了为 `depths` 数组“分配”的空间的末尾。

**接下来的调用**，比如 `obtain(chunk, geom.clamped, P * 3, 128)`，会重复这个过程：

- 它接收的 `chunk` 值是 `P * sizeof(float)`。
- 它会基于这个值计算下一个128字节对齐的地址。
- 然后再次将 `chunk` 指针向前移动 `P * 3 * sizeof(bool)`（或 `char`）个字节。

这个过程不断重复，`chunk` 指针就像一个雪球越滚越大，它的数值始终等于当前所有已“分配”成员（包括对齐产生的空隙）的总大小。

### 1.2 preprocess 预处理

这里初看有点麻烦，`gaussian-splatting\submodules\diff-gaussian-rasterization\cuda_rasterizer\rasterizer_impl.cu` 调用 `gaussian-splatting\submodules\diff-gaussian-rasterization\cuda_rasterizer\forward.cu` 的 `FORWARD::preprocess`，
```cpp
/// 这个preprocess函数经过一层封装，实际上是并行调用preprocessCUDA对每个高斯球进行处理：
void FORWARD::preprocess(int P, int D, int M,
	const float* means3D,
	const glm::vec3* scales,
	const float scale_modifier,
	const glm::vec4* rotations,
	const float* opacities,
	const float* shs,
	bool* clamped,
	const float* cov3D_precomp,
	const float* colors_precomp,
	const float* viewmatrix,
	const float* projmatrix,
	const glm::vec3* cam_pos,
	const int W, int H,
	const float focal_x, float focal_y,
	const float tan_fovx, float tan_fovy,
	int* radii,
	float2* means2D,
	float* depths,
	float* cov3Ds,
	float* rgb,
	float4* conic_opacity,
	const dim3 grid,
	uint32_t* tiles_touched,
	bool prefiltered,
	bool antialiasing)
{
	preprocessCUDA<NUM_CHANNELS> << <(P + 255) / 256, 256 >> > (
		P, D, M,
		means3D,
		scales,
		scale_modifier,
		rotations,
		opacities,
		shs,
		clamped,
		cov3D_precomp,
		colors_precomp,
		viewmatrix, 
		projmatrix,
		cam_pos,
		W, H,
		tan_fovx, tan_fovy,
		focal_x, focal_y,
		radii,
		means2D,
		depths,
		cov3Ds,
		rgb,
		conic_opacity,
		grid,
		tiles_touched,
		prefiltered,
		antialiasing
		);
}
```
`FORWARD::preprocess` 函数本身是一个在 CPU 上运行的普通 C++ 函数。它的核心作用是作为启动 GPU 计算的“发射台”。这个功能是通过这行代码实现的：
这里的 `<<<...>>>` 是 CUDA C++ 的核心语法，称为**核函数启动（Kernel Launch）**。它告诉 CPU：在 GPU 上并行执行名为 `preprocessCUDA` 的函数。

让我们分解 `<<<...>>>` 内部的参数：

`<<< GridDim, BlockDim >>>`

1. **`BlockDim` (块维度): `256`**
    - 这指定了**每个线程块（Block）中有多少个线程**。在这里，每个块包含 256 个线程，块就是 tiles，线程就是 tiles 里面的像素。
    - 一个线程块内的线程可以相互协作（例如，使用共享内存和同步障壁），是 GPU 调度的基本单位之一。
2. **`GridDim` (网格维度): `(P + 255) / 256`**
    - 这指定了**要启动多少个线程块**来组成一个网格（Grid）。
    - 这里的 `P` 是高斯球的总数量。
    - 表达式 `(P + 255) / 256` 是一种在整数运算中实现**向上取整**的常用技巧。它计算的是：为了处理 `P` 个高斯球，并且每个块处理 256 个，我们总共需要多少个块。
    - **例如**：如果 `P = 1000`，那么 `(1000 + 255) / 256 = 1255 / 256 = 4`。这意味着系统会启动 4 个线程块。

**为什么是并行处理每个高斯球？**

1. **总线程数**：GPU 启动的总线程数是 `GridDim * BlockDim`，即 `((P + 255) / 256) * 256`。这个结果是一个大于或等于 `P` 的数。

2. **线程到数据的映射**：在 `preprocessCUDA` 核函数内部，有这样一行代码：
	
	`auto idx = cg::this_grid().thread_rank();`
	这行代码为网格中的每一个线程分配一个唯一的全局索引 `idx`，从 0 开始。

3. **一对一处理**：接下来的代码将 `idx` 直接用作数组的索引来访问和处理第 `idx` 个高斯球的数据。

#### 1.2.1 总结

整个流程是这样的：

1. CPU 调用 `FORWARD::preprocess` 函数。
2. 该函数使用 `<<<...>>>` 语法，请求 GPU 启动一个由 `(P + 255) / 256` 个线程块组成的网格，每个块有 256 个线程。
3. GPU 接收指令，并**同时**执行成千上万个 `preprocessCUDA` 函数的实例（即线程）。
4. 每个线程获得一个唯一的 `idx`，并独立地、并行地对第 `idx` 个高斯球执行从坐标转换、协方差计算到颜色计算等一系列预处理操作。

因此，**一个 CPU 函数调用**通过 CUDA 的核函数启动机制，被转换成了**在 GPU 上的 `P` 次并行计算**，完美地实现了“并行调用preprocessCUDA对每个高斯球进行处理”这一目标，极大地利用了 GPU 的并行计算能力。


## 2 计算
**首先**在 `submodules\diff-gaussian-rasterization\cuda_rasterizer\rasterizer_impl.cu：int CudaRasterizer::Rasterizer::forward` 包含了前向传播的全部内容。下面的笔记也是根据这个顺序来写。

```cpp

```

![image.png](https://gitee.com/ye-zixiao/myob_pic/raw/master/20250218172351829.png)

### 2.1 computeCov3D
在 `submodules\diff-gaussian-rasterization\cuda_rasterizer\forward.cu` 定义
设置了**Ｒ**和**Ｓ**的获取方式，
```python
glm::mat3 S = glm::mat3(1.0f);
S[0][0] = mod * scale.x;
S[1][1] = mod * scale.y;
S[2][2] = mod * scale.z;
```
这里的 `mod` 可以传入 `python` 程序中的值，用于放大和缩小显示的高斯球
R
```python
// Normalize quaternion to get valid rotation
glm::vec4 q = rot;// / glm::length(rot);
float r = q.x;
float x = q.y;
float y = q.z;
float z = q.w;

// Compute rotation matrix from quaternion
glm::mat3 R = glm::mat3(
	1.f - 2.f * (y * y + z * z), 2.f * (x * y - r * z), 2.f * (x * z + r * y),
	2.f * (x * y + r * z), 1.f - 2.f * (x * x + z * z), 2.f * (y * z - r * x),
	2.f * (x * z - r * y), 2.f * (y * z + r * x), 1.f - 2.f * (x * x + y * y)
);
```

### 2.2 `computeCov2D`
在 `submodules\diff-gaussian-rasterization\cuda_rasterizer\forward.cu` 定义
作用将 3D 的变成 2D，计算 2D 的协方差矩阵。

#### 2.2.1 计算投影 w2c
视图矩阵（viewmatrix）是 w2c
透视投影是相机平面到像平面。
```python
	float3 t = transformPoint4x3(mean, viewmatrix);

	const float limx = 1.3f * tan_fovx;
	const float limy = 1.3f * tan_fovy;
	float txtz = t.x / t.z;
	float tytz = t.y / t.z;
	t.x = min(limx, max(-limx, txtz)) * t.z;
	t.y = min(limy, max(-limy, tytz)) * t.z;
	txtz = t.x / t.z;
	tytz = t.y / t.z;
```
- 首先把世界坐标系的位置转化到相机坐标系中。
- 然后对，`tx` `ty` 进行限制。
只渲染视锥体内的点，而且 txtz 都是归一化后的

`txtz` 是透视投影的效果

#### 2.2.2 Jacobi 矩阵

```cpp
float3 t = transformPoint4x3(mean, viewmatrix);// 高斯球中心点坐标变换到相机坐标系
const float limx = 1.3f * tan_fovx;
const float limy = 1.3f * tan_fovy;
float txtz = t.x / t.z;
float tytz = t.y / t.z;
t.x = min(limx, max(-limx, txtz)) * t.z;
t.y = min(limy, max(-limy, tytz)) * t.z;
txtz = t.x / t.z;
tytz = t.y / t.z;
	
glm::mat3 J = glm::mat3(
	focal_x / t.z, 0.0f, -(focal_x * t.x) / (t.z * t.z),
	0.0f, focal_y / t.z, -(focal_y * t.y) / (t.z * t.z),
	0, 0, 0);
```

#### 2.2.3 2d 协方差计算 $\Sigma_i^{\prime}$

```cpp
	glm::mat3 W = glm::mat3(
		viewmatrix[0], viewmatrix[4], viewmatrix[8],
		viewmatrix[1], viewmatrix[5], viewmatrix[9],
		viewmatrix[2], viewmatrix[6], viewmatrix[10]);
	glm::mat3 T = W * J;
	glm::mat3 Vrk = glm::mat3(
		cov3D[0], cov3D[1], cov3D[2],
		cov3D[1], cov3D[3], cov3D[4],
		cov3D[2], cov3D[4], cov3D[5]);

	glm::mat3 cov = glm::transpose(T) * glm::transpose(Vrk) * T;
```
上面的**雅可比矩阵 J** 蕴含**相机内参**的信息、**视角变换矩阵 W** 蕴含**相机外参**信息。于是已知相机内外参和 3D 协方差矩阵 $\Sigma$ 则可计算高斯球投影在成像平面上的 2D 协方差矩阵 $\Sigma^{\prime}$。

#### 2.2.4 结果处理
**行列式**
```cpp
cov2D[0] = float(cov[0][0] + kernel_size);
cov2D[1] = float(cov[0][1]);
cov2D[2] = float(cov[1][1] + kernel_size);
const float det_0 = max(1e-6, cov[0][0] * cov[1][1] - cov[0][1] * cov[0][1]);
const float det_1 = max(1e-6, (cov[0][0] + kernel_size) * (cov[1][1] + kernel_size) - cov[0][1] * cov[0][1]);
coef = sqrt(det_0 / (det_1+1e-6) + 1e-6);
if (det_0 <= 1e-6 || det_1 <= 1e-6){
	coef = 0.0f;
}
```
经过上面的雅克比矩阵得到了 cov2d 的值，但是需要进行数值稳定性的处理，增加对角线的值，使协方差矩阵更稳定，避免过拟合或数值问题。
- det_0 是原始协方差矩阵的行列式，代表其“面积”或**不确定性的大小**。
- det_1 是调整后的协方差矩阵的行列式，可能代表平滑后的不确定性。
- 如果原始或调整后的行列式过小（接近奇异矩阵），强制 `coef = 0`，表示该分布无效或贡献可忽略。

**特征值和特征向量**

```cpp
	glm::mat3 Vrk_eigen_vector;
	glm::vec3 Vrk_eigen_value;
	int D = glm_modification::findEigenvaluesSymReal(Vrk,Vrk_eigen_value,Vrk_eigen_vector);
	unsigned int min_id = Vrk_eigen_value[0]>Vrk_eigen_value[1]? (Vrk_eigen_value[1]>Vrk_eigen_value[2]?2:1):(Vrk_eigen_value[0]>Vrk_eigen_value[2]?2:0);

```

- **输入**：3x3 对称协方差矩阵 `Vrk`（表示 3D 高斯分布的形状）。
- **输出**：
    - `Vrk_eigen_value`：特征值（按大小排序）。
    - `Vrk_eigen_vector`：对应的特征向量矩阵（正交矩阵）。
- **目的**：分解协方差矩阵，用于后续逆矩阵计算和奇异值处理。

**求逆**
```cpp
	glm::mat3 Vrk_inv;
	bool well_conditioned = Vrk_eigen_value[min_id]>0.00000001;
	glm::vec3 eigenvector_min;
	if(well_conditioned)
	{
		glm::mat3 diag = glm::mat3( 1/Vrk_eigen_value[0], 0, 0,
									0, 1/Vrk_eigen_value[1], 0,
									0, 0, 1/Vrk_eigen_value[2] );
		Vrk_inv = Vrk_eigen_vector * diag * glm::transpose(Vrk_eigen_vector);
	}
	else
	{
		eigenvector_min = Vrk_eigen_vector[min_id];
		Vrk_inv = glm::outerProduct(eigenvector_min,eigenvector_min);
	}
```
- **逻辑**：若最小特征值接近 0（矩阵接近奇异），则标记为“病态”（ill-conditioned）。
- **良态矩阵**：通过特征值分解求逆
- **病态矩阵**：使用最小特征向量构造秩 1 近似逆

**相机坐标系下**
```cpp
	glm::mat3 cov_cam_inv = glm::transpose(W) * Vrk_inv * W;
	glm::vec3 uvh = {txtz, tytz, 1};
	glm::vec3 uvh_m = cov_cam_inv * uvh;
	glm::vec3 uvh_mn = glm::normalize(uvh_m);

	if(isnan(uvh_mn.x)|| D==0)
	{
		for(int ch = 0; ch < 6; ch++)
			camera_plane[ch] = 0;
		*output_normal = {0,0,0};
		*ray_plane = {0,0};
	}
```
- **输入**：`W` 是视图矩阵的旋转部分（将点从世界坐标系变换到相机坐标系）。
- **作用**：将逆协方差矩阵从世界坐标系变换到相机坐标系。
- 异常处理：归一化结果包含 NaN，或特征值分解失败（`D == 0`）
	- 将相机平面参数、法线等置零，避免无效数据传播

**几何参数计算**

```cpp
		float u2 = txtz * txtz;
		float v2 = tytz * tytz;
		float uv = txtz * tytz;

		float l = sqrt(t.x*t.x+t.y*t.y+t.z*t.z);
		glm::mat3 nJ = glm::mat3(
			1 / t.z, 0.0f, -(t.x) / (t.z * t.z),
			0.0f, 1 / t.z, -(t.y) / (t.z * t.z),
			t.x/l, t.y/l, t.z/l);

		glm::mat3 nJ_inv = glm::mat3(
			v2 + 1,	-uv, 		0,
			-uv,	u2 + 1,		0,
			-txtz,	-tytz,		0
		);
```
- **nJ**：描述从 3D 相机坐标到 2D 投影坐标的导数关系。
- **nJ_inv**：用于反向映射（从投影坐标到相机坐标）。

有一段条件编译的，好像并没有使用

```cpp
		float vbn = glm::dot(uvh_mn, uvh);
		float factor_normal = l / (u2+v2+1);
		glm::vec3 plane = nJ_inv * (uvh_mn/max(vbn,0.0000001f));
		float nl = u2+v2+1;
		glm::vec2 camera_plane_x = {(-(v2 + 1)*t.z+plane[0]*t.x)/nl/focal_x, (uv*t.z+plane[1]*t.x)/nl/focal_y};
		glm::vec2 camera_plane_y = {(uv*t.z+plane[0]*t.y)/nl/focal_x, (-(u2 + 1)*t.z+plane[1]*t.y)/nl/focal_y};
		glm::vec2 camera_plane_z = {(t.x+plane[0]*t.z)/nl/focal_x, (t.y+plane[1]*t.z)/nl/focal_y};

		*ray_plane = {plane[0]*l/nl/focal_x, plane[1]*l/nl/focal_y};

		camera_plane[0] = camera_plane_x.x;
		camera_plane[1] = camera_plane_x.y;
		camera_plane[2] = camera_plane_y.x;
		camera_plane[3] = camera_plane_y.y;
		camera_plane[4] = camera_plane_z.x;
		camera_plane[5] = camera_plane_z.y;


		glm::vec3 ray_normal_vector = {-plane[0]*factor_normal, -plane[1]*factor_normal, -1};
		glm::vec3 cam_normal_vector = nJ * ray_normal_vector;
		glm::vec3 normal_vector = glm::normalize(cam_normal_vector);

		*output_normal = {normal_vector.x, normal_vector.y, normal_vector.z};
```
### 2.3 并行预处理函数 `preprocessCUDA`
**渲染的预处理过程**
```cpp
// Perform initial steps for each Gaussian prior to rasterization.
template<int C, bool INTE = false>
__global__ void preprocessCUDA(int P, int D, int M, // P是高斯椭球的数量，D和M与球谐函数有关
	const float* orig_points,
	const glm::vec3* scales,
	const float scale_modifier,
	const glm::vec4* rotations,
	const float* opacities,
	const float* shs,
	bool* clamped,
	const float* cov3D_precomp,
	const float* colors_precomp,
	const float* viewmatrix,
	const float* projmatrix,
	const glm::vec3* cam_pos,
	const int W, int H,
	const float tan_fovx, float tan_fovy,
	const float focal_x, float focal_y,
	const float kernel_size,
	int* radii,                            //高斯球半径
	float2* points_xy_image,
	float3* view_points,
	float* depths,
	float* camera_planes,
	float2* ray_planes,
	float3* normals,
	float* cov3Ds,
	float* rgb,
	float4* conic_opacity,
	const dim3 grid,
	uint32_t* tiles_touched,             //高斯球在图片上覆盖的tile数量
	bool prefiltered,
	float* invraycov3Ds,
	float* ts,
	bool* conditions)
```


```cpp
	auto idx = cg::this_grid().thread_rank(); //线程索引编号，区间为[0,num_threads)
	if (idx >= P)
		return; //如果编号大于高斯球的数量，则返回，也就是说一个线程对应一个高斯球处理

	// Initialize radius and touched tiles to 0. If this isn't changed,
	// this Gaussian will not be processed further.
	radii[idx] = 0; //高斯球半径
	tiles_touched[idx] = 0; //高斯球在图片上覆盖的tile数量
```

#### 2.3.1 **剔除近处的高斯球**

[[04.3DGS丨代码#2.1.3 变换矩阵]] 
```cpp
	// Perform near culling, quit if outside.
	float3 p_view;
	if (!in_frustum(idx, orig_points, viewmatrix, projmatrix, prefiltered, p_view))
		return; //执行近剔除，如果高斯球离成像平面太近则退出
		
```
---
	函数：`infrustum` 在 `submodules\diff-gaussian-rasterization\cuda_rasterizer\auxiliary.h`
用于检查一个点（由 `idx` 索引）是否位于视锥体内，经过视图矩阵和投影矩阵的变换后。
```cpp
__forceinline__ __device__ bool in_frustum(int idx, // 索引
	const float* orig_points,//初始点
	const float* viewmatrix,//视图变换矩阵
	const float* projmatrix, //投影矩阵
	bool prefiltered, //是否被标记
	float3& p_view)//输出参数，用于存储变换后的点在视图空间中的坐标。
{
	float3 p_orig = { orig_points[3 * idx], orig_points[3 * idx + 1], orig_points[3 * idx + 2] };

	// Bring points to screen space
	float4 p_hom = transformPoint4x4(p_orig, projmatrix);
	float p_w = 1.0f / (p_hom.w + 0.0000001f);
	float3 p_proj = { p_hom.x * p_w, p_hom.y * p_w, p_hom.z * p_w };
	p_view = transformPoint4x3(p_orig, viewmatrix);

	if (p_view.z <= 0.2f)// || ((p_proj.x < -1.3 || p_proj.x > 1.3 || p_proj.y < -1.3 || p_proj.y > 1.3)))
	{
		if (prefiltered)
		{
			printf("Point is filtered although prefiltered is set. This shouldn't happen!");
			__trap();
		}
		return false;
	}
	return true;
}
```
- 使用投影矩阵 `projmatrix` 将点 `p_orig` 转换为齐次坐标 `p_hom`，即将点从世界空间或相机空间转换到屏幕空间。
- 使用齐次坐标的 `w` 分量进行透视除法，将点的坐标转换为标准化设备坐标（NDC）。为了避免 `w` 为零的情况，加了一个小值 `0.0000001f`。
- 函数检查该点是否位于相机后方（即 `p_view.z <= 0.2f`）。如果是，并且该点被标记为已筛选（`prefiltered`），则打印错误信息，并通过 `__trap()` 停止程序执行。若点位于相机后方，则认为它不在视锥体内，返回 `false`。否则则返回 `true`
---
#### 2.3.2 高斯球中心坐标转换到相机坐标系

```cpp
	// Transform point by projecting
	float3 p_orig = { orig_points[3 * idx], orig_points[3 * idx + 1], orig_points[3 * idx + 2] }; //高斯球中心在世界空间下的坐标
	float4 p_hom = transformPoint4x4(p_orig, projmatrix); //世界空间坐标直接转NDC坐标，并且自动变齐次
	float p_w = 1.0f / (p_hom.w + 0.0000001f);
	float3 p_proj = { p_hom.x * p_w, p_hom.y * p_w, p_hom.z * p_w }; //齐次转回非齐次
```


#### 2.3.3 由高斯球参数计算 3D 协方差矩阵
参考 [[04.3DGS丨代码#3.1 computeCov3D]]
```cpp
	// If 3D covariance matrix is precomputed, use it, otherwise compute
	// from scaling and rotation parameters. 
	const float* cov3D;
	if (cov3D_precomp != nullptr)
	{
		cov3D = cov3D_precomp + idx * 6; //预设的3D协方差
	}
	else
	{
		computeCov3D(scales[idx], scale_modifier, rotations[idx], cov3Ds + idx * 6); //用高斯球的scales和rotations其3D协方差，放进cov3Ds里
		cov3D = cov3Ds + idx * 6; //从cov3Ds里读取高斯球的3D协方差矩阵
	}
```
- `+6` 是因为会存协方差的 6 个数进去。
#### 2.3.4 返回 2D 的 condition

```cpp
	float cov2D[3];
	float ceof;
	bool condition = computeCov2D<INTE>(p_orig, focal_x, focal_y, tan_fovx, tan_fovy, kernel_size, cov3D, viewmatrix, cov2D, camera_planes + idx * 6, normals + idx, ray_planes + idx, ceof, invraycov3Ds + idx * 6);
	if constexpr (INTE)
	{
		conditions[idx] = condition;
	}
	ts[idx] = sqrt(p_view.x*p_view.x+p_view.y*p_view.y+p_view.z*p_view.z);
	const float3 cov = {cov2D[0], cov2D[1], cov2D[2]};
	// Invert covariance (EWA algorithm)
	float det = (cov.x * cov.z - cov.y * cov.y);
	if (det == 0.0f)
		return;
	float det_inv = 1.f / det;
	float3 conic = { cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv };

```
所以为了后面渲染过程方便计算的逆协方差矩阵为 `conic`，称为“锥体 (conic) 参数”

#### 2.3.5 计算高斯球与成像平面上哪些 tiles 相交
![image.png](https://gitee.com/ye-zixiao/myob_pic/raw/master/20250730181334368.png)


```cpp
	float mid = 0.5f * (cov.x + cov.z);
	float lambda1 = mid + sqrt(max(0.1f, mid * mid - det));
	float lambda2 = mid - sqrt(max(0.1f, mid * mid - det));
	float my_radius = ceil(3.f * sqrt(max(lambda1, lambda2)));
	float2 point_image = { ndc2Pix(p_proj.x, W), ndc2Pix(p_proj.y, H) };
	uint2 rect_min, rect_max;
	getRect(point_image, my_radius, rect_min, rect_max, grid); //计算高斯球覆盖了哪些tile，返回rect_min, rect_max
	if ((rect_max.x - rect_min.x) * (rect_max.y - rect_min.y) == 0)
		return;
```
定义：**二维高斯分布的“半径”** ，$3\sigma$ 原则会覆盖几乎全部的高斯分布，因此需要从协方差矩阵得到方差：
$$\Sigma = 
\begin{bmatrix}
a & b \\
b & c
\end{bmatrix}
$$
协方差矩阵的特征值 $\lambda_1, \lambda_2​$ 代表了沿着各自主轴的方差。
计算特征值：
$$
(a-\lambda)(b-\lambda)   - b^2 = 0
$$
根据一元二次方程组的解，$x=\frac{-b-\sqrt{b^2-4ac}}{2a}$ 就是代码中的公式写法。

---
```cpp
__forceinline__ __device__ void getRect(const float2 p, int max_radius, uint2& rect_min, uint2& rect_max, dim3 grid)
{
	rect_min = {
		min(grid.x, max((int)0, (int)((p.x - max_radius) / BLOCK_X))),
		min(grid.y, max((int)0, (int)((p.y - max_radius) / BLOCK_Y)))
	};
	rect_max = {
		min(grid.x, max((int)0, (int)((p.x + max_radius + BLOCK_X - 1) / BLOCK_X))),
		min(grid.y, max((int)0, (int)((p.y + max_radius + BLOCK_Y - 1) / BLOCK_Y)))
	};
}
```
可以看出，计算方法是以高斯球中心为中点，边长为长轴半径 x2 的方形区域的相交区域

`max ((int) 0, (int)((p.x - max_radius) / BLOCK_X))` 返回的是 2d 椭球占的第？个 tile，然后和 grid，也就是当前前程做比较，看看这个线程是否会处理这个

#### 2.3.6 从球谐函数系数求投影点颜色
```cpp
	// If colors have been precomputed, use them, otherwise convert
	// spherical harmonics coefficients to RGB color.
	if (colors_precomp == nullptr)
	{
		glm::vec3 result = computeColorFromSH(idx, D, M, (glm::vec3*)orig_points, *cam_pos, shs, clamped);
		rgb[idx * C + 0] = result.x;
		rgb[idx * C + 1] = result.y;
		rgb[idx * C + 2] = result.z;
	}
```

#### 2.3.7 之后重要的参数值

```cpp
	// Store some useful helper data for the next steps.
	depths[idx] = p_view.z; //该高斯椭球中心距成像平面距离(深度)
	radii[idx] = my_radius; //该高斯椭球投影在成像平面上的长轴半径
	points_xy_image[idx] = point_image; //该高斯椭球中心在成像平面上的像素坐标
	// Inverse 2D covariance and opacity neatly pack into one float4
	conic_opacity[idx] = { conic.x, conic.y, conic.z, opacities[idx] }; //高斯椭球的协方差逆矩阵和透明度放在一起了
	tiles_touched[idx] = (rect_max.y - rect_min.y) * (rect_max.x - rect_min.x); //该高斯椭球与多少个tiles相交
}
```


### 2.4 高斯球排序

#### 2.4.1 初始化
![image.png](https://gitee.com/ye-zixiao/myob_pic/raw/master/20250626155049841.png)

```cpp
	CHECK_CUDA(cub::DeviceScan::InclusiveSum(geomState.scanning_space, geomState.scan_size, geomState.tiles_touched, geomState.point_offsets, P), debug) //计算tiles_touched数组的前缀和存到point_offsets中，从后面的代码可以看出，每个高斯椭球都在BinningState都分配了一片显存空间存储与其相交的所有tiles的数据，每个高斯椭球相交的tiles数量都不一样，这里point_offsets就存着每个高斯椭球对应的显存空间起点
```

调用了 **CUB (CUDA UnBound)** 库的 `DeviceScan::InclusiveSum`，它是一个 **GPU并行前缀和（scan）** 操作的实现。下面我逐部分解释这段代码的功能和用途：
`InclusiveSum` 计算的是 **包含当前元素的前缀和**，用于：

> `out[i] = in[0] + in[1] + ... + in[i]` （包含自己）

这是在许多并行算法中非常核心的操作，比如数据压缩、分段处理、排序分桶、稀疏张量构建、光栅化预处理等。
```cpp
cub::DeviceScan::InclusiveSum(
    geomState.scanning_space,     // void* 缓冲区（第一次调用时可为 NULL）
    geomState.scan_size,          // 缓冲区大小（第一次调用时获取所需大小）
    geomState.tiles_touched,      // 输入数组（如每个 tile 的高斯数）
    geomState.point_offsets,      // 输出数组（prefix sum 结果）
    P                             // 元素数量
)

```


```cpp
	// Retrieve total number of Gaussian instances to launch and resize aux buffers
	int num_rendered;
	CHECK_CUDA(cudaMemcpy(&num_rendered, geomState.point_offsets + P - 1, sizeof(int), cudaMemcpyDeviceToHost), debug); //指针point_offsets+P-1是point_offsets数组(tiles_touched数组的前缀和数组)的最后一个元素的值，也即总共覆盖的tiles数量，把它赋给num_rendered，所以num_rendered就是需要渲染的tiles总量，被多个高斯球覆盖的tiles重复计数

```
是从 **GPU device 内存** 中将最后一个元素复制到 CPU host 内存，目的是得到前缀和的最后一个值（也就是总数），这在使用 `cub::DeviceScan::InclusiveSum` 后是很常见的模式。

| 组件                                | 含义                                                                                                               |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| `cudaMemcpy(...)`                 | CUDA 函数：在 host/device                                                                                            |
| `&num_rendered`                   | CPU 端的变量，用来接收复制结                                                                                                 |
| `geomState.point_of  geomState. point_offsets 是首地址，指向 GPU 端数组 `point_offsets` 的 **最后一个元素**（`P` 是数组长度）。这是 inclusive scan 的最终累加结果。 加结果。 加结果。 加结果。 加结果。 |
| `sizeof(int)`                                                                                                                                        |
| `cudaMemcpyDeviceToHost`                                                                                                                             |
| `CHECK_CUDA(...)                                                                                                                                     |



#### 2.4.2 构造排序用的 Keys

![image.png](https://gitee.com/ye-zixiao/myob_pic/raw/master/20250626160644309.png)

`submodules\diff-gaussian-rasterization\cuda_rasterizer\rasterizer_impl.cu：duplicateWithKeys`
目前为止，`FORWARD::preprocess` 和前面的初始化中计算了 `geomState` 中的各项：高斯椭球中心在成像平面上的像素坐标 `geomState.means2D`、高斯椭球中心距成像平面距离 `geomState.depths`、每个高斯椭球对应的存储相交 tiles 的显存空间起点 `geomState.point_offsets`，以及高斯椭球投影在成像平面上的长轴半径 `radii`； `binningState` 里每个高斯椭球都都分配了一片显存空间存储与其相交的所有 tiles 的数据。接下来将其放进 `duplicateWithKeys` 中初始化 key 用于排序，每个高斯球一个线程。

`duplicateWithKeys` 是 Gaussian Splatting 中 **tile-aware binning（分桶）** 的关键步骤。它会为每一个可见高斯生成 **多个键值对 (key/value)**，以便之后用 GPU 排序将它们按 tile 和 depth 进行组织。这一步本质上是一个 **空间划分 + 深度排序预处理**。
**为每个高斯生成一个或多个 key/value pair，key 是 tile+depth，value 是高斯索引。**

```cpp
// Generates one key/value pair for all Gaussian / tile overlaps. 
// Run once per Gaussian (1:N mapping).
__global__ void duplicateWithKeys(
	int P,
	const float2* points_xy,
	const float* depths,
	const uint32_t* offsets,
	uint64_t* gaussian_keys_unsorted,
	uint32_t* gaussian_values_unsorted,
	int* radii,
	dim3 grid)
{
	auto idx = cg::this_grid().thread_rank();//用idx获取当前线程的全局索引
	if (idx >= P)  
		return;

	// Generate no key/value pair for invisible Gaussians
	if (radii[idx] > 0)//如果是不可见的高斯（半径不大于0），则不生成键值对。这可能是因为这些高斯在屏幕上不可见，不需要处理。
	{
		// Find this Gaussian's offset in buffer for writing keys/values.
		uint32_t off = (idx == 0) ? 0 : offsets[idx - 1];//获取offsets数组中的偏移量off。offsets数组存储的是每个高斯对应的键值对在输出数组中的起始位置。例如，每个高斯可能覆盖多个tile，因此需要多个键值对，而offsets数组记录了每个高斯在输出数组中的起始位置。
		uint2 rect_min, rect_max;

		getRect(points_xy[idx], radii[idx], rect_min, rect_max, grid);

		// For each tile that the bounding rect overlaps, emit a 
		// key/value pair. The key is |  tile ID  |      depth      |,
		// and the value is the ID of the Gaussian. Sorting the values 
		// with this key yields Gaussian IDs in a list, such that they
		// are first sorted by tile and then by depth. 
		for (int y = rect_min.y; y < rect_max.y; y++)
		{
			for (int x = rect_min.x; x < rect_max.x; x++)
			{
				uint64_t key = y * grid.x + x;
				key <<= 32;
				key |= *((uint32_t*)&depths[idx]);//depth是浮点数，但这里用uint32_t指针转换后取其二进制表示，这可能是因为需要将浮点数深度作为整数处理，
				gaussian_keys_unsorted[off] = key;
				gaussian_values_unsorted[off] = idx;
				off++;
			}
		}
	}
}
```
1. 每个线程处理一个高斯。
2. 如果高斯不可见（半径<=0），跳过。
3. 计算该高斯覆盖的 tile 范围（rect_min 到 rect_max）。
4. 对于每个覆盖的 tile，生成一个键（tile ID + depth）和值（高斯 ID）。
5. 将这些键值对写入到 gaussian_keys_unsorted 和 gaussian_values_unsorted 数组的对应位置，位置由 offsets 数组决定

这样，每个高斯覆盖的每个 tile 都会生成一个键值对，其中 key 的高 32 位是 tile 的 ID，低 32 位是 depth 的二进制表示。之后，对这些键值对进行排序时，首先按 tile ID 排序，同一 tile 内的按 depth 排序。这样在渲染时，可以按 tile 顺序处理，每个 tile 内按深度排序，可能用于透明度处理或者正确的前后顺序。


#### 2.4.3 键值对排序：`cub::DeviceRadixSort::SortPairs`
```cpp
	// Sort complete list of (duplicated) Gaussian indices by keys
	CHECK_CUDA(cub::DeviceRadixSort::SortPairs(
		binningState.list_sorting_space,// 临时工作空间指针（由CUB管理）
		binningState.sorting_size,// 临时空间大小（需预先计算）
		binningState.point_list_keys_unsorted,// 输入未排序的键数组
		 binningState.point_list_keys,// 输出排序后的键数组
		binningState.point_list_unsorted, // 输入未排序的值数组（高斯ID）
		binningState.point_list,// 输出排序后的值数组
		num_rendered,// 待排序的元素数量（实际生成的高斯键值对数）
		 0, // 排序起始位（从第0位开始）
		 32 + bit// 排序总位数（高32位Tile ID + 低bit位深度）
		 ), debug)

	CHECK_CUDA(cudaMemset(imgState.ranges, 0, tile_grid.x * tile_grid.y * sizeof(uint2)), debug);
```
- **基数排序（Radix Sort）**：适用于整数键的稳定排序，此处直接对 64 位键的二进制表示排序。


#### 2.4.4 计算每个 tile 要渲染的部分在 `point_list_keys` 上的起点和终点
```cpp
	// Identify start and end of per-tile workloads in sorted list
	if (num_rendered > 0)
		identifyTileRanges << <(num_rendered + 255) / 256, 256 >> > (
			num_rendered, //已生成的高斯键值对总数（即排序后列表长度）。
			binningState.point_list_keys, //排序后的键数组（键 = Tile ID + 深度）
			imgState.ranges); //输出存储每个Tile的索引范围（uint2数组，长度 = Tile总数）。
	CHECK_CUDA(, debug);
```
- 遍历已排序的高斯键值对列表，记录每个 Tile 的**起始索引**和**结束索引**，存储在 `imgState.ranges` 数组中。
- 每个 tile 分配两个 uint，，其中 x 表示起始索引，y 表示结束索引。
- 每个要渲染的 key 都启动一个 `identifyTileRanges` 检查是否是 `point_list_keys` 上的 tile 起点或终点，如果是，将 idx 写入 `imgState.ranges`：

---
```cpp
// Check keys to see if it is at the start/end of one tile's range in 
// the full sorted list. If yes, write start/end of this tile. 
// Run once per instanced (duplicated) Gaussian ID.
__global__ void identifyTileRanges(int L, uint64_t* point_list_keys, uint2* ranges)
{
	auto idx = cg::this_grid().thread_rank();
	if (idx >= L)
		return;

	// Read tile ID from key. Update start/end of tile range if at limit.
	uint64_t key = point_list_keys[idx]; //读取当前线程对应的键。
	uint32_t currtile = key >> 32;
	if (idx == 0)
		ranges[currtile].x = 0;
	else
	{
		uint32_t prevtile = point_list_keys[idx - 1] >> 32;
		if (currtile != prevtile) //比较当前Tile和前一个元素的Tile是否不同。如果不同，说明前一个Tile的结束是当前索引，当前Tile的起始也是当前索引
		{
			ranges[prevtile].y = idx;
			ranges[currtile].x = idx;
		}
	}
	if (idx == L - 1)
		ranges[currtile].y = L;
}
```
- 遍历已按 Tile ID 排序的键值对列表，记录每个 Tile 的**起始索引**和**结束索引**，存储在 `ranges` 数组中。
- `point_list_keys` 必须已按 Tile ID 排序，同一 Tile 的高斯连续存储。
---



### 2.5 FORWARD::render
- **`FORWARD::render` 对 `grid` 个 tile 各启动 `block` (16x16x1) 个线程，即每个像素一个线程运行 `renderCUDA`**
```cpp
	CHECK_CUDA(FORWARD::render(
		tile_grid, block,
		imgState.ranges,
		binningState.point_list,
		width, height,
		geomState.view_points,
		geomState.means2D,
		feature_ptr,
		geomState.ts,
		geomState.camera_planes,
		geomState.ray_planes,
		geomState.normals,
		geomState.conic_opacity,
		focal_x, focal_y,
		out_alpha,
		imgState.n_contrib,
		background,
		out_color,
		out_coord,
		out_mcoord,
		out_normal,
		out_depth,
		out_mdepth,
		maxweight_indices,
		imgState.accum_coord,
		imgState.accum_depth,
		imgState.normal_length,
		require_coord,
		require_depth), debug);

	return num_rendered;
}
```

---
调用的是 `submodules\diff-gaussian-rasterization\cuda_rasterizer\forward.cu中的renderCUDA函数`
这里比原版的高斯多了很多的参数，有比较多的几何特征计算。
```cpp
template <uint32_t CHANNELS, bool COORD, bool DEPTH, bool NORMAL>
__global__ void __launch_bounds__(BLOCK_X * BLOCK_Y)
renderCUDA(
	const uint2* __restrict__ ranges,
	const uint32_t* __restrict__ point_list,
	int W, int H,
	const float* __restrict__ view_points,
	const float2* __restrict__ points_xy_image,
	const float* __restrict__ features,
	const float* __restrict__ ts,
	const float* __restrict__ camera_planes,
	const float2* __restrict__ ray_planes,
	const float3* __restrict__ normals,
	const float4* __restrict__ conic_opacity,
	const float focal_x, 
	const float focal_y,
	float* __restrict__ out_alpha,
	uint32_t* __restrict__ n_contrib,
	const float* __restrict__ bg_color,
	float* __restrict__ out_color,
	float* __restrict__ out_coord,
	float* __restrict__ out_mcoord,
	float* __restrict__ out_normal,
	float* __restrict__ out_depth,
	float* __restrict__ out_mdepth,
	int* __restrict__ maxweight_indices,
	float* __restrict__ accum_coord,
	float* __restrict__ accum_depth,
	float* __restrict__ normal_length
	)
```

#### 2.5.1 **线程配置与像素映射**
```cpp
	// Identify current tile and associated min/max pixel range.
	auto block = cg::this_thread_block();
	uint32_t horizontal_blocks = (W + BLOCK_X - 1) / BLOCK_X;
	uint2 pix_min = { block.group_index().x * BLOCK_X, block.group_index().y * BLOCK_Y };  //该tile覆盖范围的像素坐标
	uint2 pix_max = { min(pix_min.x + BLOCK_X, W), min(pix_min.y + BLOCK_Y , H) };
	uint2 pix = { pix_min.x + block.thread_index().x, pix_min.y + block.thread_index().y }; //该thread需要处理的像素的坐标
	uint32_t pix_id = W * pix.y + pix.x;  //该thread对应的像素编号
	float2 pixf = { (float)pix.x, (float)pix.y }; 
	float2 pixnf = {(pixf.x-W/2.f)/focal_x,(pixf.y-H/2.f)/focal_y};   //代表归一化屏幕坐标的PIXNF。
	float ln = sqrt(pixnf.x*pixnf.x+pixnf.y*pixnf.y+1);  //将2D像素位置投射到3D空间的向量的长度，从本质上代表“视图向量”幅度。
```
- `block` 当前线程属于第几个 block（tile）
- `pix_min` / `pix_max`：当前 Tile 覆盖的像素范围（如 16x16）。
- `pix`：当前线程负责的像素坐标。
- `pix_id`：线性化像素索引（`W * pix.y + pix.x`）。
- `pixnf`：将像素坐标转换为归一化设备坐标（NDC），用于 3D 计算。
- `ln`：计算视图方向向量的长度，用于深度值归一化（如将射线参数 `t` 转换为深度）。

#### 2.5.2  **加载 Tile 对应的高斯列表**
```cpp
	// Load start/end range of IDs to process in bit sorted list.
	uint2 range = ranges[block.group_index().y * horizontal_blocks + block.group_index().x];
	const int rounds = ((range.y - range.x + BLOCK_SIZE - 1) / BLOCK_SIZE);
	int toDo = range.y - range.x;//当前线程即要处理的高斯球数量
```
- `ranges` 数组存储每个 Tile 的高斯索引范围（`range.x` 起始，`range.y` 结束）。
- `rounds` 把当前线程即要处理的高斯球每 `BLOCK_SIZE` 个分一个 `batch`，之后 for 循环里是一个 `batch` 处理

#### 2.5.3 读取高斯数据在缓存中
对 `rounds` （batch）开始处理，将数据缓存在共享内存中。
```cpp
// Iterate over batches until all done or range is complete
for (int i = 0; i < rounds; i++, toDo -= BLOCK_SIZE)
{
	// End if entire block votes that it is done rasterizing
	int num_done = __syncthreads_count(done);
	if (num_done == BLOCK_SIZE)
		break;

	// Collectively fetch per-Gaussian data from global to shared
	int progress = i * BLOCK_SIZE + block. thread_rank ();
	if (range. x + progress < range. y)
	{
		int coll_id = point_list[range. x + progress];
		collected_id[block. thread_rank ()] = coll_id;
		collected_xy[block. thread_rank ()] = points_xy_image[coll_id];
		collected_conic_opacity[block. thread_rank ()] = conic_opacity[coll_id];
		for (int ch = 0; ch < CHANNELS; ch++)
			collected_feature[ch * BLOCK_SIZE + block. thread_rank ()] = features[coll_id * CHANNELS + ch];
		if constexpr (COORD)
		{
			for (int ch = 0; ch < 6; ch++)
				collected_camera_plane[ch * BLOCK_SIZE + block. thread_rank ()] = camera_planes[coll_id * 6 + ch];
			for (int ch = 0; ch < 3; ch++)
				collected_mean3d[ch * BLOCK_SIZE + block. thread_rank ()] = view_points[coll_id * 3 + ch];
		}
		if constexpr (DEPTH)
		{
			collected_ts[block. thread_rank ()] = ts[coll_id];
			collected_ray_planes[block. thread_rank ()] = ray_planes[coll_id];
		}
		if constexpr (NORMAL)
		{
			collected_normals[block. thread_rank ()] = normals[coll_id];
		}
	}
	block.sync ();
```
- `block. thread_rank ()` 线程 (thread) 在线程块内（block）的局部索引
#### 2.5.4 计算高斯权重

```cpp
// Iterate over current batch
for (int j = 0; !done && j < min (BLOCK_SIZE, toDo); j++)
{
	// Keep track of current position in range
	contributor++;

	// Resample using conic matrix (cf. "Surface 
	// Splatting" by Zwicker et al., 2001)
	float2 xy = collected_xy[j];
	float2 d = { xy. x - pixf. x, xy. y - pixf. y };
	float4 con_o = collected_conic_opacity[j];
	float power = -0.5f * (con_o.x * d.x * d.x + con_o.z * d.y * d.y) - con_o.y * d.x * d.y;
	if (power > 0.0f){
		continue;
	}
```

- `xy` 坐标，`d` 是像素到高斯中心的偏移，`con_o` 是协方差矩阵参数和不透明度
参考依据是： 
$$
\frac{1}{2} \mathbf{x}^T \Sigma^{-1} \mathbf{x} = -\frac{1}{2} \begin{bmatrix} \Delta x & \Delta y \end{bmatrix} \begin{bmatrix} A & B \\ B & C \end{bmatrix} \begin{bmatrix} \Delta x \\ \Delta y \end{bmatrix}
= -\frac{1}{2} A (\Delta x)^2 - B \Delta x \Delta y - \frac{1}{2} C (\Delta y)^2
$$
其中
$$
(\Delta x , \Delta y)^T = (x_i, y_i)^T - (x_{pixel}-y_{pixel})^T
$$
$x_i, y_i$ 是高斯投影的中心坐标。

#### 2.5.5 alpha-blending
```cpp
			// Eq. (2) from 3D Gaussian splatting paper.
			// Obtain alpha by multiplying with Gaussian opacity
			// and its exponential falloff from mean.
			// Avoid numerical instabilities (see paper appendix). 
			float alpha = min (0.99f, con_o.w * exp (power));
			if (alpha < 1.0f / 255.0f)
				continue;
			float test_T = T * (1 - alpha);
			if (test_T < 0.0001f)
			{
				done = true;
				continue;
			}

			const float aT = alpha * T;
			// Eq. (3) from 3D Gaussian splatting paper.
			for (int ch = 0; ch < CHANNELS; ch++)
				C[ch] += collected_feature[j + BLOCK_SIZE * ch] * aT;
```

按深度顺序混合每个高斯对像素的透明度和颜色贡献。
- 透明度混合：$T_{new} = T_p \cdot (1-\alpha)$
- 颜色累加：$C=feature \cdot \alpha \cdot T_{new}$

#### 2.5.6 处理 3D 坐标相关的计算
根据高斯的 2D 投影偏移调整其 3D 坐标，并按透明度权重累加到像素的最终坐标输出。

```cpp
if constexpr (COORD)
{
	float2 camera_plane0 = {collected_camera_plane[j], collected_camera_plane[j + BLOCK_SIZE]};
	float2 camera_plane1 = {collected_camera_plane[j + BLOCK_SIZE * 2], collected_camera_plane[j + BLOCK_SIZE * 3]};
	float2 camera_plane2 = {collected_camera_plane[j + BLOCK_SIZE * 4], collected_camera_plane[j + BLOCK_SIZE * 5]};
	float coord[3] = {collected_mean3d[j] + camera_plane0. x * d.x + camera_plane0. y * d.y,
						collected_mean3d[j + BLOCK_SIZE] + camera_plane1. x * d.x + camera_plane1. y * d.y,
						collected_mean3d[j + BLOCK_SIZE * 2] + camera_plane2. x * d.x + camera_plane2. y * d.y};
	for (int ch = 0; ch < 3; ch++)
		Coord[ch] += coord[ch] * aT;
	if (before_median){
		for (int ch = 0; ch < 3; ch++)
			mCoord[ch] = coord[ch];
	}
}
```
-  `collected_camera_plane` 存储每个高斯的 6 个平面参数（每个参数按 `BLOCK_SIZE` 间隔排列）：平面参数用于将 2D 像素偏移（`d.x`, `d.y`）映射到 3D 空间，可能对应相机投影的局部坐标系基向量。
- - **参数解析**：
    - `collected_mean3d[j]`：高斯在 3D 空间中的原始位置（x 坐标）。
    - `collected_mean3d[j + BLOCK_SIZE]`：y 坐标。
    - `collected_mean3d[j + BLOCK_SIZE * 2]`：z 坐标。
- **公式意义**：  
    根据像素到高斯中心的 2D 偏移（`d.x`, `d.y`），沿相机平面参数调整 3D 坐标。  
    例如：  $x_{\mathrm{adjusted}}=x_{\mathrm{mean}}+\mathrm{plane}0_{x}\cdot d.x+\mathrm{plane}0_{y}\cdot d.y$
	这相当于在 3D 空间中沿局部平面方向平移高斯位置，模拟其在图像平面上的投影形变。

#### 2.5.7 depth 深度图

```cpp
if constexpr (DEPTH) {
    float t_center = collected_ts[j]; // 高斯中心的射线参数（沿视图方向）
    float2 ray_plane = collected_ray_planes[j]; // 射线平面方程系数
    float t = t_center + (ray_plane. x * d.x + ray_plane. y * d.y); // 调整后的射线参数
    Depth += t * aT; // 加权累加深度
    if (before_median) mDepth = t; // 记录中值前的深度
}
```
- `before_median`为真时（如透明度累积未超过 50%），记录当前深度到`mDepth`，用于近似中值或主要遮挡物深度。
- 最终深度为所有覆盖高斯的加权平均。

#### 2.5.8 normal 法向量

```cpp
if constexpr (NORMAL) {
    Normal[0] += collected_normals[j]. x * aT; // 累加 X 分量
    Normal[1] += collected_normals[j]. y * aT; // 累加 Y 分量
    Normal[2] += collected_normals[j]. z * aT; // 累加 Z 分量
}
```
- **操作**：将高斯的法线向量按权重`aT`累加到像素法线缓冲区。
- **后续处理**：  
    最终需对累加后的法线归一化（见之前代码中的`sqrt (Normal[0]^2 + ... )`），得到单位法线向量。
- **物理意义**：  
    加权平均法线用于表面光照计算，反映多个高斯共同作用的方向。

#### 2.5.9 几何贡献者追踪（GEO 条件编译）

```cpp
if constexpr (GEO) { if (before_median) max_contributor = contributor; // 记录透明度累积中值前的贡献者索引 }
```
- **变量**：
    - `contributor`：当前处理的高斯计数（从 0 开始）。
    - `max_contributor`：记录在透明度累积到 50%前处理的最后一个高斯索引。
- **用途**：  
    可能用于识别对像素贡献最大的高斯（如主要遮挡物），或在后续流程中限制计算范围。